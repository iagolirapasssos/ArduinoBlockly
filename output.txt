app.js:
const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs').promises; // Use a versão promise do fs
const { exec } = require('child_process');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const sanitize = require('sanitize-filename');

const app = express();
const port = 3000;

app.use(bodyParser.json());
app.use('/static', express.static('static'));

app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
});

app.post('/upload', async (req, res) => {
    const { port, board, code } = req.body;

    const sketchName = sanitize(`temporary_sketch_${uuidv4()}`);
    const sketchDir = path.join(__dirname, 'sketches', sketchName);
    const sketchPath = path.join(sketchDir, `${sketchName}.ino`);

    try {
        await fs.mkdir(sketchDir, { recursive: true });
        await fs.writeFile(sketchPath, code);

        try {
            await fs.access(sketchPath);
        } catch (err) {
            return res.status(500).json({ error: 'Failed to create sketch file' });
        }

        const command = `arduino-cli compile -b ${board} ${sketchDir} && arduino-cli upload -p ${port} -b ${board} ${sketchDir}`;
        exec(command, { cwd: sketchDir }, async (error, stdout, stderr) => {
            await deleteDirectoryRecursive(sketchDir);

            if (error) {
                console.error(`Error: ${error.message}`);
                return res.status(500).json({ error: error.message });
            }
            if (stderr) {
                console.error(`Stderr: ${stderr}`);
                return res.status(500).json({ error: stderr });
            }
            console.log(`Stdout: ${stdout}`);
            res.json({ message: 'Upload successful', output: stdout });
        });
    } catch (err) {
        console.error(`Error: ${err.message}`);
        return res.status(500).json({ error: err.message });
    }
});

async function deleteDirectoryRecursive(directoryPath) {
    try {
        const files = await fs.readdir(directoryPath);
        await Promise.all(files.map(async (file) => {
            const curPath = path.join(directoryPath, file);
            const stat = await fs.lstat(curPath);
            if (stat.isDirectory()) {
                await deleteDirectoryRecursive(curPath);
            } else {
                await fs.unlink(curPath);
            }
        }));
        await fs.rmdir(directoryPath);
    } catch (err) {
        console.error(`Error deleting directory ${directoryPath}:`, err);
    }
}

app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});


client.js:
const express = require('express');
const { exec } = require('child_process');
const bodyParser = require('body-parser');
const serialport = require('serialport');
const fs = require('fs').promises;

const app = express();
const port = 4000; // Porta do cliente

app.use(bodyParser.json());

// Rota para detectar portas seriais onde as placas Arduino estão conectadas
app.get('/detect', async (req, res) => {
    try {
        const ports = await serialport.list();
        const boards = ports.map(port => ({
            path: port.path,
            manufacturer: port.manufacturer
        }));
        res.json(boards);
    } catch (err) {
        console.error('Erro ao detectar portas seriais:', err);
        res.status(500).send('Erro ao detectar portas seriais');
    }
});

// Rota para fazer upload de código para a placa Arduino
app.post('/upload', (req, res) => {
    const { board, port, code } = req.body;

    // Criar sketch temporário
    const sketchName = 'temporary_sketch';
    const sketchDir = `/tmp/sketches/${sketchName}`;
    const sketchPath = `${sketchDir}/${sketchName}.ino`;

    fs.mkdir(sketchDir, { recursive: true })
        .then(() => fs.writeFile(sketchPath, code))
        .then(() => {
            const command = `arduino-cli compile -b ${board} ${sketchDir} && arduino-cli upload -p ${port} -b ${board} ${sketchDir}`;

            exec(command, (error, stdout, stderr) => {
                if (error) {
                    console.error(`Erro: ${error.message}`);
                    return res.status(500).send(`Erro: ${error.message}`);
                }
                if (stderr) {
                    console.error(`Erro: ${stderr}`);
                    return res.status(500).send(`Erro: ${stderr}`);
                }
                res.send(`Upload bem-sucedido: ${stdout}`);
            });
        })
        .catch((err) => {
            console.error(`Erro ao criar sketch: ${err.message}`);
            res.status(500).send(`Erro ao criar sketch: ${err.message}`);
        });
});

app.listen(port, () => {
    console.log(`Cliente rodando em http://localhost:${port}`);
});


index.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Arduino Blockly IDE</title>
    <link rel="stylesheet" href="static/style.css">
    <link rel="icon" href="static/favicon.ico">
    <script src="https://unpkg.com/blockly/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly/msg/en.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="#">File</a>
                    <ul>
                        <li><a href="#" id="saveBtn">Save</a></li>
                        <li><a href="#" id="openBtn">Open</a></li>
                    </ul>
                </li>
                <li><a href="#">Help</a>
                    <ul>
                        <li><a href="#">About</a></li>
                        <li><a href="#">Contact</a></li>
                        <li><a href="#">Documents</a></li>
                    </ul>
                </li>
                <li><a href="#" id="executeBtn">Run</a></li>
            </ul>
        </nav>
    </header>
    <div class="container">
        <div class="main-content">
            <div class="editor-container" id="editor-container">
                <div class="arduino-controls-container">
                    <div class="control-group">
                        <label for="serial-port">Select Serial Port:</label>
                        <div class="input-button-group">
                            <select id="serial-port">
                                <option value="">Select a port</option>
                            </select>
                            <button id="connect-button">Conectar ao Arduino</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="board">Select Board:</label>
                        <div class="input-button-group">
                            <select id="board">
                                <option value="arduino:avr:uno">Arduino Uno</option>
                                <option value="arduino:avr:mega">Arduino Mega</option>
                            </select>
                            <button id="upload-button">Upload to Arduino</button>
                        </div>
                    </div>
                </div>
                <p>
                <div id="blocklyDiv" class="blockly-area"></div>
                <xml id="toolbox" style="display: none">
                    <category name="Logic" colour="%{BKY_LOGIC_HUE}">
                        <block type="controls_if"></block>
                        <block type="logic_compare"></block>
                        <block type="logic_operation"></block>
                        <block type="logic_negate"></block>
                        <block type="logic_boolean"></block>
                        <block type="logic_null"></block>
                        <block type="logic_ternary"></block>
                    </category>
                    <category name="Loops" colour="%{BKY_LOOPS_HUE}">
                        <block type="controls_repeat_ext">
                            <value name="TIMES">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="controls_whileUntil"></block>
                        <block type="controls_for">
                            <value name="FROM">
                                <shadow type="math_number">
                                    <field name="NUM">1</field>
                                </shadow>
                            </value>
                            <value name="TO">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                            <value name="BY">
                                <shadow type="math_number">
                                    <field name="NUM">1</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="controls_forEach"></block>
                        <block type="controls_flow_statements"></block>
                    </category>
                    <category name="Math" colour="%{BKY_MATH_HUE}">
                        <block type="math_number">
                          <field name="NUM">0</field>
                        </block>
                        <block type="math_arithmetic"></block>
                        <block type="math_single"></block>
                        <block type="math_trig"></block>
                        <block type="math_constant"></block>
                        <block type="math_number_property"></block>
                        <block type="math_round"></block>
                        <block type="math_on_list"></block>
                        <block type="math_modulo"></block>
                        <block type="math_constrain">
                            <value name="LOW">
                                <shadow type="math_number">
                                    <field name="NUM">1</field>
                                </shadow>
                            </value>
                            <value name="HIGH">
                                <shadow type="math_number">
                                    <field name="NUM">100</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="math_random_int">
                            <value name="FROM">
                                <shadow type="math_number">
                                    <field name="NUM">1</field>
                                </shadow>
                            </value>
                            <value name="TO">
                                <shadow type="math_number">
                                    <field name="NUM">100</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="math_random_float"></block>
                    </category>
                    <category name="Text" colour="%{BKY_TEXTS_HUE}">
                        <block type="text"></block>
                        <block type="text_join"></block>
                        <block type="text_append">
                            <value name="TEXT">
                                <shadow type="text"></shadow>
                            </value>
                        </block>
                        <block type="text_length"></block>
                        <block type="text_isEmpty"></block>
                        <block type="text_indexOf">
                            <value name="VALUE">
                                <block type="variables_get">
                                    <field name="VAR">text</field>
                                </block>
                            </value>
                        </block>
                        <block type="text_charAt">
                            <value name="VALUE">
                                <block type="variables_get">
                                    <field name="VAR">text</field>
                                </block>
                            </value>
                        </block>
                        <block type="text_getSubstring">
                            <value name="STRING">
                                <block type="variables_get">
                                    <field name="VAR">text</field>
                                </block>
                            </value>
                        </block>
                        <block type="text_changeCase"></block>
                        <block type="text_trim"></block>
                        <block type="text_print"></block>
                        <block type="text_prompt_ext">
                            <value name="TEXT">
                                <shadow type="text"></shadow>
                            </value>
                        </block>
                    </category>
                    <category name="Lists" colour="%{BKY_LISTS_HUE}">
                        <block type="lists_create_with"></block>
                        <block type="lists_create_with">
                            <mutation items="0"></mutation>
                        </block>
                        <block type="lists_repeat">
                            <value name="NUM">
                                <shadow type="math_number">
                                    <field name="NUM">5</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="lists_length"></block>
                        <block type="lists_isEmpty"></block>
                        <block type="lists_indexOf">
                            <value name="VALUE">
                                <block type="variables_get">
                                    <field name="VAR">list</field>
                                </block>
                            </value>
                        </block>
                        <block type="lists_getIndex">
                            <value name="VALUE">
                                <block type="variables_get">
                                    <field name="VAR">list</field>
                                </block>
                            </value>
                        </block>
                        <block type="lists_setIndex">
                            <value name="LIST">
                                <block type="variables_get">
                                    <field name="VAR">list</field>
                                </block>
                            </value>
                        </block>
                        <block type="lists_getSublist">
                            <value name="LIST">
                                <block type="variables_get">
                                    <field name="VAR">list</field>
                                </block>
                            </value>
                        </block>
                        <block type="lists_split">
                            <value name="DELIM">
                                <shadow type="text">
                                    <field name="TEXT">,</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="lists_sort"></block>
                    </category>
                    <category name="Variables" colour="%{BKY_VARIABLES_HUE}">
                        <block type="variables_declare_number"></block>
                        <block type="variables_declare_text"></block>
                        <block type="variables_declare_boolean"></block>
                        <block type="variables_get_number"></block>
                        <block type="variables_get_text"></block>
                        <block type="variables_get_boolean"></block>
                    </category>
                    <category name="Functions" colour="%{BKY_PROCEDURES_HUE}" custom="PROCEDURE"></category>
                    
                    <category name="Custom Code" colour="210">
                        <block type="custom_code"></block>
                    </category>
        
                    <category name="Arduino" colour="230">
                        <block type="arduino_setup"></block>
                        <block type="arduino_loop"></block>
                        <block type="arduino_digital_write"></block>
                        <block type="arduino_digital_read"></block>
                        <block type="serial_begin"></block>
                        <block type="analog_read"></block>
                        <block type="digital_read"></block>
                        <block type="digital_write"></block>
                        <block type="pin_mode"></block>
                        <block type="analog_write"></block>
                        <block type="analog_reference"></block>
                        <block type="delay"></block>
                        <block type="delay_microseconds"></block>
                        <block type="micros"></block>
                        <block type="millis"></block>
                        <block type="no_tone"></block>
                        <block type="tone"></block>
                        <block type="pulse_in"></block>
                        <block type="pulse_in_long"></block>
                    </category>
                    <category name="Extensions" colour="160" id="extensionsCategory">
                        <button text="Send Extension" callbackKey="sendExtension"></button>
                    </category>
                </xml>
            </div>
            <div class="output-container" id="output-container">
                <div class="resize-handle"></div>
                <h2>Output</h2>
                <pre id="code-output" class="hljs language-cpp"></pre>
            </div>
        </div>
        <div class="serial-monitor-container">
            <h2>Monitor Serial</h2>
            <div id="serialMonitor" class="serial-monitor"></div>
        </div>
        <input type="file" id="extensionInput" style="display:none;" />
    </div>

    <script src="static/arduino_blocks.js"></script>
    <script src="static/arduino_generator.js"></script>
    <script src="static/script.js"></script>
    <script src="static/setup.js"></script>
</body>
</html>

LICENSE:
MIT License

Copyright (c) 2024 Iago lira

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


package.json:
{
  "name": "ArduinoBlockly",
  "version": "1.0.0",
  "description": "Projeto para listar portas seriais e compilar código Arduino usando Blockly",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "@blockly/field-multilineinput": "^5.0.10",
    "@blockly/theme-dark": "^7.0.1",
    "@blockly/workspace-backpack": "^6.0.2",
    "axios": "^1.7.7",
    "body-parser": "^1.20.2",
    "child_process": "^1.0.2",
    "cors": "^2.8.5",
    "ejs": "^3.1.10",
    "express": "^4.19.2",
    "https-localhost": "^4.7.1",
    "jsdom": "^21.1.2",
    "module-alias": "^2.2.3",
    "sanitize-filename": "^1.6.3",
    "serialport": "^9.2.8",
    "uuid": "^10.0.0",
    "ws": "^7.5.10"
  },
  "author": "Francisco Iago Lira Passos",
  "license": "MIT"
}


static/arduino_blocks.js:
// static/arduino_blocks.js
Blockly.Blocks['text_print'] = {
    init: function() {
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.appendValueInput("TEXT")
            .setCheck(null)
            .appendField(new Blockly.FieldDropdown([["println", "PRINTLN"], ["print", "PRINT"]]), "MODE");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Prints text to the serial monitor.");
        this.setHelpUrl("");
    }
};


Blockly.Blocks['arduino_setup'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Setup");
        this.appendStatementInput("SETUP")
            .setCheck(null);
        this.setColour(230);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['serial_begin'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Serial.begin")
            .appendField(new Blockly.FieldDropdown([
                ["9600", "9600"], 
                ["19200", "19200"], 
                ["38400", "38400"], 
                ["57600", "57600"], 
                ["115200", "115200"]
            ]), "BAUD_RATE");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Initialize the serial communication with the specified baud rate.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['analog_read'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("analogRead")
            .appendField(new Blockly.FieldDropdown([
                ["A0", "A0"], ["A1", "A1"], ["A2", "A2"], ["A3", "A3"], ["A4", "A4"], ["A5", "A5"]
            ]), "PIN");
        this.setOutput(true, "Number");
        this.setColour(160);
        this.setTooltip("Read the value from the specified analog pin.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['digital_read'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("digitalRead")
            .appendField(new Blockly.FieldDropdown([
                ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"], ["12", "12"], ["13", "13"]
            ]), "PIN");
        this.setOutput(true, "Boolean");
        this.setColour(160);
        this.setTooltip("Read the value from the specified digital pin.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['digital_write'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("digitalWrite")
            .appendField(new Blockly.FieldDropdown([
                ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"], ["12", "12"], ["13", "13"]
            ]), "PIN")
            .appendField(new Blockly.FieldDropdown([
                ["HIGH", "HIGH"], ["LOW", "LOW"]
            ]), "STATE");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Write the specified value to the specified digital pin.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['pin_mode'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("pinMode")
            .appendField(new Blockly.FieldDropdown([
                ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"], ["12", "12"], ["13", "13"]
            ]), "PIN")
            .appendField(new Blockly.FieldDropdown([
                ["INPUT", "INPUT"], ["OUTPUT", "OUTPUT"], ["INPUT_PULLUP", "INPUT_PULLUP"]
            ]), "MODE");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Set the mode of the specified pin.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['analog_write'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("analogWrite")
            .appendField(new Blockly.FieldDropdown([
                ["3", "3"], ["5", "5"], ["6", "6"], ["9", "9"], ["10", "10"], ["11", "11"]
            ]), "PIN")
            .appendField(new Blockly.FieldNumber(0, 0, 255), "VALUE");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Write an analog value (PWM) to the specified pin.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['analog_reference'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("analogReference")
            .appendField(new Blockly.FieldDropdown([
                ["DEFAULT", "DEFAULT"], ["INTERNAL", "INTERNAL"], ["INTERNAL1V1", "INTERNAL1V1"], ["INTERNAL2V56", "INTERNAL2V56"], ["EXTERNAL", "EXTERNAL"]
            ]), "TYPE");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Configures the reference voltage used for analog input.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['delay'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("delay")
            .appendField(new Blockly.FieldNumber(0), "TIME");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Pauses the program for the amount of time (in milliseconds) specified as parameter.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['delay_microseconds'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("delayMicroseconds")
            .appendField(new Blockly.FieldNumber(0), "TIME");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Pauses the program for the amount of time (in microseconds) specified as parameter.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['micros'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("micros");
        this.setOutput(true, "Number");
        this.setColour(160);
        this.setTooltip("Returns the number of microseconds since the Arduino board began running the current program.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['millis'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("millis");
        this.setOutput(true, "Number");
        this.setColour(160);
        this.setTooltip("Returns the number of milliseconds since the Arduino board began running the current program.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['no_tone'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("noTone")
            .appendField(new Blockly.FieldDropdown([
                ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"], ["12", "12"], ["13", "13"]
            ]), "PIN");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Stops the generation of a square wave triggered by tone().");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['tone'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("tone")
            .appendField(new Blockly.FieldDropdown([
                ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"], ["12", "12"], ["13", "13"]
            ]), "PIN")
            .appendField(new Blockly.FieldNumber(0, 0), "FREQUENCY")
            .appendField("Hz")
            .appendField("for")
            .appendField(new Blockly.FieldNumber(0, 0), "DURATION")
            .appendField("ms");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Generates a square wave of the specified frequency (and 50% duty cycle) on a pin. Optionally, a duration can be specified.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['pulse_in'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("pulseIn")
            .appendField(new Blockly.FieldDropdown([
                ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"], ["12", "12"], ["13", "13"]
            ]), "PIN")
            .appendField(new Blockly.FieldDropdown([
                ["HIGH", "HIGH"], ["LOW", "LOW"]
            ]), "STATE");
        this.setOutput(true, "Number");
        this.setColour(160);
        this.setTooltip("Reads a pulse (either HIGH or LOW) on a pin.");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['pulse_in_long'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("pulseInLong")
            .appendField(new Blockly.FieldDropdown([
                ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"], ["12", "12"], ["13", "13"]
            ]), "PIN")
            .appendField(new Blockly.FieldDropdown([
                ["HIGH", "HIGH"], ["LOW", "LOW"]
            ]), "STATE");
        this.setOutput(true, "Number");
        this.setColour(160);
        this.setTooltip("Reads a pulse (either HIGH or LOW) on a pin. For long pulse widths.");
        this.setHelpUrl("");
    }
};


//END ARDUINO

Blockly.Blocks['arduino_loop'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Loop");
        this.appendStatementInput("LOOP")
            .setCheck(null);
        this.setColour(230);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['arduino_digital_write'] = {
    init: function() {
        this.appendValueInput("PIN")
            .setCheck("Number")
            .appendField("Digital Write PIN#");
        this.appendValueInput("STATE")
            .setCheck("Boolean")
            .appendField("State");
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(230);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['arduino_digital_read'] = {
    init: function() {
        this.appendValueInput("PIN")
            .setCheck("Number")
            .appendField("Digital Read PIN#");
        this.setInputsInline(true);
        this.setOutput(true, "Boolean");
        this.setColour(230);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

Blockly.Blocks['math_number'] = {
  init: function() {
    this.appendDummyInput()
        .appendField(new Blockly.FieldNumber(0), "NUM");
    this.setOutput(true, "Number");
    this.setColour(230);
    this.setTooltip("");
    this.setHelpUrl("");
  }
};

//Math
//Declare
// Variable Declaration Blocks
Blockly.Blocks['variables_declare_number'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Declare number")
            .appendField(new Blockly.FieldTextInput("myVarNumber"), "VAR_NAME")
            .appendField(new Blockly.FieldDropdown([
                ["byte", "byte"],
                ["int", "int"],
                ["float", "float"],
                ["long", "long"],
                ["double", "double"]
            ]), "TYPE");
        this.appendValueInput("VALUE")
            .setCheck("Number")
            .appendField("value");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(330);
        this.setTooltip("Declare a number variable");
        this.setHelpUrl("");
    },
    onchange: function(event) {
        if (event.type === Blockly.Events.BLOCK_CREATE || 
            event.type === Blockly.Events.BLOCK_CHANGE || 
            event.type === Blockly.Events.BLOCK_MOVE) {
            const varName = this.getFieldValue('VAR_NAME');
            const varType = 'NUMBER';
            const workspace = this.workspace;
            let variable = workspace.getVariable(varName, varType);
            if (!variable) {
                workspace.createVariable(varName, varType);
            } else if (variable.type !== varType) {
                workspace.deleteVariableById(variable.getId());
                workspace.createVariable(varName, varType);
            }
        }
    }
};

Blockly.Blocks['variables_declare_text'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Declare text")
            .appendField(new Blockly.FieldTextInput("myVarText"), "VAR_NAME")
            .appendField(new Blockly.FieldDropdown([
                ["char", "char"],
                ["String", "String"]
            ]), "TYPE");
        this.appendValueInput("VALUE")
            .setCheck("String")
            .appendField("value");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(230);
        this.setTooltip("Declare a text variable");
        this.setHelpUrl("");
    },
    onchange: function(event) {
        if (event.type === Blockly.Events.BLOCK_CREATE || 
            event.type === Blockly.Events.BLOCK_CHANGE || 
            event.type === Blockly.Events.BLOCK_MOVE) {
            const varName = this.getFieldValue('VAR_NAME');
            const varType = 'TEXT';
            const workspace = this.workspace;
            let variable = workspace.getVariable(varName, varType);
            if (!variable) {
                workspace.createVariable(varName, varType);
            } else if (variable.type !== varType) {
                workspace.deleteVariableById(variable.getId());
                workspace.createVariable(varName, varType);
            }
        }
    }
};

Blockly.Blocks['variables_declare_boolean'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Declare boolean")
            .appendField(new Blockly.FieldTextInput("myVarBool"), "VAR_NAME")
            .appendField(new Blockly.FieldDropdown([
                ["true", "true"],
                ["false", "false"]
            ]), "TYPE");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip("Declare a boolean variable");
        this.setHelpUrl("");
    },
    onchange: function(event) {
        if (event.type === Blockly.Events.BLOCK_CREATE || 
            event.type === Blockly.Events.BLOCK_CHANGE || 
            event.type === Blockly.Events.BLOCK_MOVE) {
            const varName = this.getFieldValue('VAR_NAME');
            const varType = 'BOOLEAN';
            const workspace = this.workspace;
            let variable = workspace.getVariable(varName, varType);
            if (!variable) {
                workspace.createVariable(varName, varType);
            } else if (variable.type !== varType) {
                workspace.deleteVariableById(variable.getId());
                workspace.createVariable(varName, varType);
            }
        }
    }
};

//Get
// Obtenção de Variáveis
// Get Number Variable
// Get Number Variable
Blockly.Blocks['variables_get_number'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Get number")
            .appendField(new Blockly.FieldVariable(
                "myVarText",
                null,
                ['NUMBER'],
                'NUMBER'
            ), "VAR");
        this.setOutput(true, "Number");
        this.setColour(330);
        this.setTooltip("Get the value of a number variable");
        this.setHelpUrl("");
    }
};

// Get Text Variable
Blockly.Blocks['variables_get_text'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Get text")
            .appendField(new Blockly.FieldVariable(
                "myVarText",
                null,
                ['TEXT'],
                'TEXT'
            ), "VAR");
        this.setOutput(true, "String");
        this.setColour(230);
        this.setTooltip("Get the value of a text variable");
        this.arguments_ = [];
        this.setHelpUrl("");
    },
};

// Get Boolean Variable
Blockly.Blocks['variables_get_boolean'] = {
    init: function() {
        this.appendDummyInput()
            .appendField("Get boolean")
            .appendField(new Blockly.FieldVariable(
                "myVarBool",
                null,
                ['BOOLEAN'],
                'BOOLEAN'
            ), "VAR");
        this.setOutput(true, "Boolean");
        this.setColour(160);
        this.setTooltip("Get the value of a boolean variable");
        this.setHelpUrl("");
    }
};
//END MATH

//Functions blocks
// Bloco para definir uma função com retorno
Blockly.Blocks['procedures_defreturn'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("function")
        .appendField(new Blockly.FieldTextInput("do something"), "NAME");
    this.appendStatementInput("STACK")
        .setCheck(null)
        .appendField("do");
    this.appendValueInput("RETURN")
        .setCheck(null)
        .appendField("return");
    this.setInputsInline(false);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
    this.arguments_ = [];
    this.setStyle('procedure_blocks');
  },
  getVars: function() {
    return this.arguments_;
  },
  getVarModels: function() {
    return this.arguments_.map(varName => this.workspace.getVariable(varName));
  }
};

// Bloco para definir uma função sem retorno
Blockly.Blocks['procedures_defnoreturn'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("function")
        .appendField(new Blockly.FieldTextInput("do something"), "NAME");
    this.appendStatementInput("STACK")
        .setCheck(null)
        .appendField("do");
    this.setInputsInline(false);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
    this.arguments_ = [];
    this.setStyle('procedure_blocks');
  },
  getVars: function() {
    return this.arguments_;
  },
  getVarModels: function() {
    return this.arguments_.map(varName => this.workspace.getVariable(varName));
  }
};

// Bloco para chamar uma função com retorno
Blockly.Blocks['procedures_callreturn'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("call")
        .appendField(new Blockly.FieldTextInput("do something"), "NAME");
    this.setOutput(true, null);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
    this.arguments_ = [];
    this.setStyle('procedure_blocks');
  },
  getVars: function() {
    return this.arguments_;
  },
  getVarModels: function() {
    return this.arguments_.map(varName => this.workspace.getVariable(varName));
  }
};

// Bloco para chamar uma função sem retorno
Blockly.Blocks['procedures_callnoreturn'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("call")
        .appendField(new Blockly.FieldTextInput("do something"), "NAME");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
    this.arguments_ = [];
    this.setStyle('procedure_blocks');
  },
  getVars: function() {
    return this.arguments_;
  },
  getVarModels: function() {
    return this.arguments_.map(varName => this.workspace.getVariable(varName));
  }
};

// Bloco para retornar condicionalmente
Blockly.Blocks['procedures_ifreturn'] = {
  init: function() {
    this.appendValueInput("CONDITION")
        .setCheck("Boolean")
        .appendField("if");
    this.appendDummyInput()
        .appendField("return");
    this.appendValueInput("VALUE")
        .setCheck(null);
    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(290);
    this.setTooltip("");
    this.setHelpUrl("");
    this.arguments_ = [];
    this.setStyle('procedure_blocks');
  },
  getVars: function() {
    return this.arguments_;
  },
  getVarModels: function() {
    return this.arguments_.map(varName => this.workspace.getVariable(varName));
  }
};
//End functions

//Custom code
Blockly.Blocks['custom_code'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Custom Code")
        .appendField(new Blockly.FieldTextInput('#include "dht.h"'), 'CUSTOM_CODE');
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(160);
    this.setTooltip("Adicione código customizado ao seu programa.");
    this.setHelpUrl("");
  }
};



static/arduino_generator.js:
// static/arduino_generator.js
Blockly.Arduino = new Blockly.Generator('Arduino');

Blockly.Arduino.ORDER_ATOMIC = 0;         // 0 "" ...
Blockly.Arduino.ORDER_UNARY_POSTFIX = 1;  // expr++ expr-- () [] .
Blockly.Arduino.ORDER_UNARY_PREFIX = 2;   // -expr !expr ~expr ++expr --expr
Blockly.Arduino.ORDER_MULTIPLICATIVE = 3; // * / % ~/
Blockly.Arduino.ORDER_ADDITIVE = 4;       // + -
Blockly.Arduino.ORDER_SHIFT = 5;          // << >>
Blockly.Arduino.ORDER_RELATIONAL = 6;     // is is! >= > <= 
Blockly.Arduino.ORDER_EQUALITY = 7;       // == != === !==
Blockly.Arduino.ORDER_BITWISE_AND = 8;    // &
Blockly.Arduino.ORDER_BITWISE_XOR = 9;    // ^
Blockly.Arduino.ORDER_BITWISE_OR = 10;    // |
Blockly.Arduino.ORDER_LOGICAL_AND = 11;   // &&
Blockly.Arduino.ORDER_LOGICAL_OR = 12;    // ||
Blockly.Arduino.ORDER_CONDITIONAL = 13;   // expr ? expr : expr
Blockly.Arduino.ORDER_ASSIGNMENT = 14;    // = += -= *= /= ~/= %= <<= >>= &= ^= |=
Blockly.Arduino.ORDER_YIELD = 15;         // yield
Blockly.Arduino.ORDER_COMMA = 16;         // ,
Blockly.Arduino.ORDER_NONE = 99;          // (...)

Blockly.Arduino.reset = function() {
    Blockly.Arduino.definitions_ = Object.create(null);
    Blockly.Arduino.setups_ = Object.create(null);
    Blockly.Arduino.loop_ = Object.create(null);
};

Blockly.Arduino.init = function(workspace) {
  Blockly.Arduino.nameDB_ = new Blockly.Names(Blockly.Arduino.RESERVED_WORDS_);
  Blockly.Arduino.nameDB_.setVariableMap(workspace.getVariableMap());
  Blockly.Arduino.reset();

  // Create a dictionary of definitions to be printed before setups.
  Blockly.Arduino.definitions_ = Object.create(null);
  // Create a dictionary of setups to be printed before the code.
  Blockly.Arduino.setups_ = Object.create(null);
  // Create a dictionary of variable definitions to be printed after setups.
  Blockly.Arduino.variables_ = Object.create(null);
  // Create a dictionary of functions from the code.
  Blockly.Arduino.functions_ = Object.create(null);
  // Create a dictionary of functions from the header.
  Blockly.Arduino.headerFunctions_ = Object.create(null);
  // Create a dictionary of functions from the user.
  Blockly.Arduino.userFunctions_ = Object.create(null);
  
};

Blockly.Arduino.finish = function(code) {
  // Convert the setups dictionary into a list.
  const setups = [];
  for (const name in Blockly.Arduino.setups_) {
    setups.push(Blockly.Arduino.setups_[name]);
  }
  // Convert the variable definitions dictionary into a list.
  const variables = [];
  for (const name in Blockly.Arduino.variables_) {
    variables.push(Blockly.Arduino.variables_[name]);
  }
  // Convert the functions dictionary into a list.
  const functions = [];
  for (const name in Blockly.Arduino.functions_) {
    functions.push(Blockly.Arduino.functions_[name]);
  }

  // Clean up temporary data.
  delete Blockly.Arduino.definitions_;
  delete Blockly.Arduino.setups_;
  delete Blockly.Arduino.variables_;
  delete Blockly.Arduino.functions_;
  Blockly.Arduino.reset();

  return setups.join('\n') + '\n' + variables.join('\n') + '\n' + functions.join('\n') + '\n\n' + code;
};

Blockly.Arduino.scrub_ = function(block, code) {
  const nextBlock = block.nextConnection && block.nextConnection.targetBlock();
  const nextCode = Blockly.Arduino.blockToCode(nextBlock);
  return code + nextCode;
};

Blockly.Arduino.blockToCode = function(block) {
  if (!block) {
    return '';
  }

  if (block.isEnabled() && !block.hasDisabledReason()) {
    var func = this[block.type];
    if (typeof func !== 'function') {
      throw Error('Language "Arduino" does not know how to generate code for block type "' + block.type + '".');
    }
    var code = func.call(this, block);

    if (Array.isArray(code)) {
      return code[0] + this.scrub_(block, code[1]);
    } else {
      return this.scrub_(block, code);
    }
  } else {
    return this.scrub_(block, '');
  }
};


Blockly.Arduino.workspaceToCode = function(workspace) {
  if (!workspace) {
    console.warn('Blockly.Arduino.workspaceToCode was called with an invalid workspace.');
    return '';
  }
  let code = [];
  this.init(workspace);
  const blocks = workspace.getTopBlocks(true);
  for (let i = 0, block; block = blocks[i]; i++) {
    let line = this.blockToCode(block);
    if (line) {
      if (Array.isArray(line)) {
        line = line[0];
      }
      code.push(line);
    }
  }
  code = code.join('\n');
  code = this.finish(code);
  return code;
};

Blockly.Arduino.prefixLines = function(text, prefix) {
    return prefix + text.replace(/\n/g, '\n' + prefix);
};

//Arduino
Blockly.Arduino['arduino_setup'] = function(block) {
    var statements_setup = Blockly.Arduino.statementToCode(block, 'SETUP');
    statements_setup = Blockly.Arduino.addLoopTrap(statements_setup, block.id) || '';
    statements_setup = Blockly.Arduino.prefixLines(statements_setup, '  ');  // Add indentation
    var code = 'void setup() {\n' + statements_setup + '\n}\n';
    
    // Adiciona o código dos blocos conectados
    var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
    if (nextBlock) {
        code += Blockly.Arduino.blockToCode(nextBlock);
    }

    return code;
};

Blockly.Arduino['arduino_loop'] = function(block) {
    var statements_loop = Blockly.Arduino.statementToCode(block, 'LOOP');
    statements_loop = Blockly.Arduino.addLoopTrap(statements_loop, block.id) || '';
    statements_loop = Blockly.Arduino.prefixLines(statements_loop, '  ');  // Add indentation
    var code = 'void loop() {\n' + statements_loop + '\n}\n';
    
    // Adiciona o código dos blocos conectados
    var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
    if (nextBlock) {
        code += Blockly.Arduino.blockToCode(nextBlock);
    }

    return code;
};

Blockly.Arduino['serial_begin'] = function(block) {
    var baudRate = block.getFieldValue('BAUD_RATE');
    var code = 'Serial.begin(' + baudRate + ');\n';
    return code;
};

Blockly.Arduino['analog_read'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var code = 'analogRead(' + pin + ');\n';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['digital_read'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var code = 'digitalRead(' + pin + ');\n';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['digital_write'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var state = block.getFieldValue('STATE');
    var code = 'digitalWrite(' + pin + ', ' + state + ');\n';
    return code;
};

Blockly.Arduino['pin_mode'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var mode = block.getFieldValue('MODE');
    var code = 'pinMode(' + pin + ', ' + mode + ');\n';
    return code;
};

Blockly.Arduino['analog_write'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var value = block.getFieldValue('VALUE');
    var code = 'analogWrite(' + pin + ', ' + value + ');\n';
    return code;
};

Blockly.Arduino['analog_reference'] = function(block) {
    var type = block.getFieldValue('TYPE');
    var code = 'analogReference(' + type + ');\n';
    return code;
};

Blockly.Arduino['delay'] = function(block) {
    var time = block.getFieldValue('TIME');
    var code = 'delay(' + time + ');\n';
    return code;
};

Blockly.Arduino['delay_microseconds'] = function(block) {
    var time = block.getFieldValue('TIME');
    var code = 'delayMicroseconds(' + time + ');\n';
    return code;
};

Blockly.Arduino['micros'] = function(block) {
    var code = 'micros();\n';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['millis'] = function(block) {
    var code = 'millis();\n';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['no_tone'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var code = 'noTone(' + pin + ');\n';
    return code;
};

Blockly.Arduino['tone'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var frequency = block.getFieldValue('FREQUENCY');
    var duration = block.getFieldValue('DURATION');
    var code = 'tone(' + pin + ', ' + frequency + ', ' + duration + ');\n';
    return code;
};

Blockly.Arduino['pulse_in'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var state = block.getFieldValue('STATE');
    var code = 'pulseIn(' + pin + ', ' + state + ');\n';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['pulse_in_long'] = function(block) {
    var pin = block.getFieldValue('PIN');
    var state = block.getFieldValue('STATE');
    var code = 'pulseInLong(' + pin + ', ' + state + ');\n';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

//END ARDUINO



/*
  NATIVES BLOCKS
*/

Blockly.Arduino['controls_if'] = function (block) {
    var n = 0;
    var code = '', branchCode, conditionCode;
    do {
        conditionCode = Blockly.Arduino.valueToCode(block, 'IF' + n, Blockly.Arduino.ORDER_NONE) || 'false';
        branchCode = Blockly.Arduino.statementToCode(block, 'DO' + n);
        code += (n > 0 ? ' else ' : '') + 'if (' + conditionCode + ') {\n' + branchCode + '}';
        n++;
    } while (block.getInput('IF' + n));

    if (block.getInput('ELSE')) {
        branchCode = Blockly.Arduino.statementToCode(block, 'ELSE');
        code += ' else {\n' + branchCode + '}';
    }

    return code + '\n';
};

Blockly.Arduino['logic_compare'] = function (block) {
    var OPERATORS = {
        'EQ': '==',
        'NEQ': '!=',
        'LT': '<',
        'LTE': '<=',
        'GT': '>',
        'GTE': '>='
    };
    var operator = OPERATORS[block.getFieldValue('OP')];
    var order = Blockly.Arduino.ORDER_RELATIONAL;
    var argument0 = Blockly.Arduino.valueToCode(block, 'A', order) || '0';
    var argument1 = Blockly.Arduino.valueToCode(block, 'B', order) || '0';
    var code = argument0 + ' ' + operator + ' ' + argument1;
    return [code, order];
};

Blockly.Arduino['logic_operation'] = function (block) {
    var operator = (block.getFieldValue('OP') === 'AND') ? '&&' : '||';
    var order = (operator === '&&') ? Blockly.Arduino.ORDER_LOGICAL_AND : Blockly.Arduino.ORDER_LOGICAL_OR;
    var argument0 = Blockly.Arduino.valueToCode(block, 'A', order) || 'false';
    var argument1 = Blockly.Arduino.valueToCode(block, 'B', order) || 'false';
    var code = argument0 + ' ' + operator + ' ' + argument1;
    return [code, order];
};

Blockly.Arduino['logic_negate'] = function (block) {
    var order = Blockly.Arduino.ORDER_LOGICAL_NOT;
    var argument0 = Blockly.Arduino.valueToCode(block, 'BOOL', order) || 'false';
    var code = '!' + argument0;
    return [code, order];
};

Blockly.Arduino['logic_boolean'] = function (block) {
    var code = (block.getFieldValue('BOOL') === 'TRUE') ? 'true' : 'false';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['logic_null'] = function (block) {
    return ['NULL', Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['logic_ternary'] = function (block) {
    var value_if = Blockly.Arduino.valueToCode(block, 'IF', Blockly.Arduino.ORDER_CONDITIONAL) || 'false';
    var value_then = Blockly.Arduino.valueToCode(block, 'THEN', Blockly.Arduino.ORDER_CONDITIONAL) || 'null';
    var value_else = Blockly.Arduino.valueToCode(block, 'ELSE', Blockly.Arduino.ORDER_CONDITIONAL) || 'null';
    var code = value_if + ' ? ' + value_then + ' : ' + value_else;
    return [code, Blockly.Arduino.ORDER_CONDITIONAL];
};

Blockly.Arduino['controls_repeat_ext'] = function (block) {
    var repeats = Blockly.Arduino.valueToCode(block, 'TIMES', Blockly.Arduino.ORDER_ATOMIC) || '0';
    var branch = Blockly.Arduino.statementToCode(block, 'DO');
    var code = 'for (int count = 0; count < ' + repeats + '; count++) {\n' + branch + '}\n';
    return code;
};

Blockly.Arduino['controls_whileUntil'] = function (block) {
    var until = block.getFieldValue('MODE') === 'UNTIL';
    var argument0 = Blockly.Arduino.valueToCode(block, 'BOOL', until ? Blockly.Arduino.ORDER_LOGICAL_NOT : Blockly.Arduino.ORDER_NONE) || 'false';
    var branch = Blockly.Arduino.statementToCode(block, 'DO');
    if (until) {
        argument0 = '!' + argument0;
    }
    return 'while (' + argument0 + ') {\n' + branch + '}\n';
};

Blockly.Arduino['controls_for'] = function (block) {
    var variable0 = Blockly.Arduino.nameDB_.getName(block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
    var argument0 = Blockly.Arduino.valueToCode(block, 'FROM', Blockly.Arduino.ORDER_ASSIGNMENT) || '0';
    var argument1 = Blockly.Arduino.valueToCode(block, 'TO', Blockly.Arduino.ORDER_ASSIGNMENT) || '0';
    var increment = Blockly.Arduino.valueToCode(block, 'BY', Blockly.Arduino.ORDER_ASSIGNMENT) || '1';
    var branch = Blockly.Arduino.statementToCode(block, 'DO');
    var code = 'for (int ' + variable0 + ' = ' + argument0 + '; ' + variable0 + ' <= ' + argument1 + '; ' + variable0;
    code += ' += ' + increment + ') {\n' + branch + '}\n';
    return code;
};

Blockly.Arduino['controls_forEach'] = function (block) {
    var variable0 = Blockly.Arduino.nameDB_.getName(block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
    var argument0 = Blockly.Arduino.valueToCode(block, 'LIST', Blockly.Arduino.ORDER_ATOMIC) || '[]';
    var branch = Blockly.Arduino.statementToCode(block, 'DO');
    var code = 'for (int ' + variable0 + ' : ' + argument0 + ') {\n' + branch + '}\n';
    return code;
};

Blockly.Arduino['controls_flow_statements'] = function (block) {
    var xfix = '';
    if (Blockly.Arduino.STATEMENT_PREFIX) {
        xfix += Blockly.Arduino.injectId(Blockly.Arduino.STATEMENT_PREFIX, block);
    }
    if (Blockly.Arduino.STATEMENT_SUFFIX) {
        xfix += Blockly.Arduino.injectId(Blockly.Arduino.STATEMENT_SUFFIX, block);
    }
    if (Blockly.Arduino.STATEMENT_PREFIX) {
        var loop = Blockly.Arduino.nameDB_.getName(block.getFieldValue('LOOP'), Blockly.PROCEDURE_CATEGORY_NAME);
        var code = loop ? 'continue;\n' : 'break;\n';
    } else {
        var code = block.getFieldValue('FLOW') === 'BREAK' ? 'break;\n' : 'continue;\n';
    }
    return xfix + code;
};

// MATH
Blockly.Arduino['math_arithmetic'] = function(block) {
  // Basic arithmetic operators, and power.
  var OPERATORS = {
    'ADD': [' + ', Blockly.Arduino.ORDER_ADDITIVE],
    'MINUS': [' - ', Blockly.Arduino.ORDER_ADDITIVE],
    'MULTIPLY': [' * ', Blockly.Arduino.ORDER_MULTIPLICATIVE],
    'DIVIDE': [' / ', Blockly.Arduino.ORDER_MULTIPLICATIVE],
    'POWER': [null, Blockly.Arduino.ORDER_NONE]  // Handle power separately.
  };
  var tuple = OPERATORS[block.getFieldValue('OP')];
  var operator = tuple[0];
  var order = tuple[1];
  var argument0 = Blockly.Arduino.valueToCode(block, 'A', order) || '0';
  var argument1 = Blockly.Arduino.valueToCode(block, 'B', order) || '0';
  var code;
  // Power in Arduino requires a special case since it has no operator.
  if (!operator) {
    code = 'pow(' + argument0 + ', ' + argument1 + ')';
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
  }
  code = argument0 + operator + argument1;
  return [code, order];
};

Blockly.Arduino['math_single'] = function (block) {
    var operator = block.getFieldValue('OP');
    var code;
    var arg;
    if (operator === 'NEG') {
        arg = Blockly.Arduino.valueToCode(block, 'NUM', Blockly.Arduino.ORDER_UNARY_NEGATION) || '0';
        code = '-' + arg;
        return [code, Blockly.Arduino.ORDER_UNARY_NEGATION];
    }
    arg = Blockly.Arduino.valueToCode(block, 'NUM', Blockly.Arduino.ORDER_NONE) || '0';
    switch (operator) {
        case 'ROOT':
            code = 'sqrt(' + arg + ')';
            break;
        case 'ABS':
            code = 'abs(' + arg + ')';
            break;
        case 'LN':
            code = 'log(' + arg + ')';
            break;
        case 'EXP':
            code = 'exp(' + arg + ')';
            break;
        case 'POW10':
            code = 'pow(10, ' + arg + ')';
            break;
        default:
            throw Error('Unknown math operator: ' + operator);
    }
    return [code, Blockly.Arduino.ORDER_FUNCTION_CALL];
};

Blockly.Arduino['math_trig'] = function (block) {
    var operator = block.getFieldValue('OP');
    var code;
    var arg;
    if (operator === 'NEG') {
        arg = Blockly.Arduino.valueToCode(block, 'NUM', Blockly.Arduino.ORDER_UNARY_NEGATION) || '0';
        code = '-' + arg;
        return [code, Blockly.Arduino.ORDER_UNARY_NEGATION];
    }
    arg = Blockly.Arduino.valueToCode(block, 'NUM', Blockly.Arduino.ORDER_NONE) || '0';
    switch (operator) {
        case 'SIN':
            code = 'sin(' + arg + ')';
            break;
        case 'COS':
            code = 'cos(' + arg + ')';
            break;
        case 'TAN':
            code = 'tan(' + arg + ')';
            break;
        case 'ASIN':
            code = 'asin(' + arg + ')';
            break;
        case 'ACOS':
            code = 'acos(' + arg + ')';
            break;
        case 'ATAN':
            code = 'atan(' + arg + ')';
            break;
        default:
            throw Error('Unknown math operator: ' + operator);
    }
    return [code, Blockly.Arduino.ORDER_FUNCTION_CALL];
};

Blockly.Arduino['math_constant'] = function (block) {
    var CONSTANTS = {
        'PI': ['PI', Blockly.Arduino.ORDER_ATOMIC],
        'E': ['M_E', Blockly.Arduino.ORDER_ATOMIC],
        'GOLDEN_RATIO': ['1.61803398875', Blockly.Arduino.ORDER_ATOMIC],
        'SQRT2': ['M_SQRT2', Blockly.Arduino.ORDER_ATOMIC],
        'SQRT1_2': ['M_SQRT1_2', Blockly.Arduino.ORDER_ATOMIC]
    };
    return CONSTANTS[block.getFieldValue('CONSTANT')];
};

Blockly.Arduino['math_number_property'] = function (block) {
    var number_to_check = Blockly.Arduino.valueToCode(block, 'NUMBER_TO_CHECK', Blockly.Arduino.ORDER_MODULUS) || '0';
    var dropdown_property = block.getFieldValue('PROPERTY');
    var code;
    if (dropdown_property === 'PRIME') {
        code = 'isPrime(' + number_to_check + ')';
    } else if (dropdown_property === 'EVEN') {
        code = number_to_check + ' % 2 == 0';
    } else if (dropdown_property === 'ODD') {
        code = number_to_check + ' % 2 == 1';
    } else if (dropdown_property === 'WHOLE') {
        code = number_to_check + ' % 1 == 0';
    } else if (dropdown_property === 'POSITIVE') {
        code = number_to_check + ' > 0';
    } else if (dropdown_property === 'NEGATIVE') {
        code = number_to_check + ' < 0';
    } else if (dropdown_property === 'DIVISIBLE_BY') {
        var divisor = Blockly.Arduino.valueToCode(block, 'DIVISOR', Blockly.Arduino.ORDER_MODULUS) || '0';
        code = number_to_check + ' % ' + divisor + ' == 0';
    }
    return [code, Blockly.Arduino.ORDER_LOGICAL_NOT];
};

Blockly.Arduino['math_round'] = function (block) {
    var operator = block.getFieldValue('OP');
    var arg = Blockly.Arduino.valueToCode(block, 'NUM', Blockly.Arduino.ORDER_NONE) || '0';
    var code;
    if (operator === 'ROUND') {
        code = 'round(' + arg + ')';
    } else if (operator === 'ROUNDUP') {
        code = 'ceil(' + arg + ')';
    } else if (operator === 'ROUNDDOWN') {
        code = 'floor(' + arg + ')';
    } else {
        throw Error('Unknown math operator: ' + operator);
    }
    return [code, Blockly.Arduino.ORDER_FUNCTION_CALL];
};

Blockly.Arduino['math_on_list'] = function (block) {
    var func = block.getFieldValue('OP');
    var list = Blockly.Arduino.valueToCode(block, 'LIST', Blockly.Arduino.ORDER_NONE) || '[]';
    var code;
    switch (func) {
        case 'SUM':
            code = list + '.reduce((x, y) => x + y, 0)';
            break;
        case 'MIN':
            code = 'Math.min.apply(null, ' + list + ')';
            break;
        case 'MAX':
            code = 'Math.max.apply(null, ' + list + ')';
            break;
        case 'AVERAGE':
            code = list + '.reduce((x, y) => x + y, 0) / ' + list + '.length';
            break;
        case 'MEDIAN':
            code = 'median(' + list + ')';
            break;
        case 'MODE':
            code = 'mode(' + list + ')';
            break;
        case 'STD_DEV':
            code = 'stdDev(' + list + ')';
            break;
        case 'RANDOM':
            code = list + '[Math.floor(Math.random() * ' + list + '.length)]';
            break;
        default:
            throw Error('Unknown operator: ' + func);
    }
    return [code, Blockly.Arduino.ORDER_FUNCTION_CALL];
};

Blockly.Arduino['math_modulo'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'DIVIDEND', Blockly.Arduino.ORDER_MODULUS) || '0';
    var argument1 = Blockly.Arduino.valueToCode(block, 'DIVISOR', Blockly.Arduino.ORDER_MODULUS) || '0';
    var code = argument0 + ' % ' + argument1;
    return [code, Blockly.Arduino.ORDER_MODULUS];
};

Blockly.Arduino['math_constrain'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_NONE) || '0';
    var argument1 = Blockly.Arduino.valueToCode(block, 'LOW', Blockly.Arduino.ORDER_NONE) || '0';
    var argument2 = Blockly.Arduino.valueToCode(block, 'HIGH', Blockly.Arduino.ORDER_NONE) || '0';
    var code = 'constrain(' + argument0 + ', ' + argument1 + ', ' + argument2 + ')';
    return [code, Blockly.Arduino.ORDER_FUNCTION_CALL];
};

Blockly.Arduino['math_random_int'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'FROM', Blockly.Arduino.ORDER_NONE) || '0';
    var argument1 = Blockly.Arduino.valueToCode(block, 'TO', Blockly.Arduino.ORDER_NONE) || '0';
    var code = 'random(' + argument0 + ', ' + argument1 + ')';
    return [code, Blockly.Arduino.ORDER_FUNCTION_CALL];
};

Blockly.Arduino['math_random_float'] = function (block) {
    return ['random(0.0, 1.0)', Blockly.Arduino.ORDER_FUNCTION_CALL];
};

//END MATH

//TEXT
Blockly.Arduino.quote_ = function(string) {
    string = string.replace(/\\/g, '\\\\')
                   .replace(/\n/g, '\\\n')
                   .replace(/'/g, '\\\'');
    return '"' + string + '"';
};

Blockly.Arduino['text'] = function (block) {
    const code = Blockly.Arduino.quote_(block.getFieldValue('TEXT'));
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['text_join'] = function (block) {
    var code;
    if (block.itemCount_ === 0) {
        return ['\'\'', Blockly.Arduino.ORDER_ATOMIC];
    } else if (block.itemCount_ === 1) {
        var argument0 = Blockly.Arduino.valueToCode(block, 'ADD0', Blockly.Arduino.ORDER_NONE) || '\'\'';
        code = 'String(' + argument0 + ')';
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    } else {
        var argument0 = Blockly.Arduino.valueToCode(block, 'ADD0', Blockly.Arduino.ORDER_NONE) || '\'\'';
        var argument1 = Blockly.Arduino.valueToCode(block, 'ADD1', Blockly.Arduino.ORDER_NONE) || '\'\'';
        code = 'String(' + argument0 + ') + String(' + argument1 + ')';
        for (var n = 2; n < block.itemCount_; n++) {
            argument1 = Blockly.Arduino.valueToCode(block, 'ADD' + n, Blockly.Arduino.ORDER_NONE) || '\'\'';
            code = code + ' + String(' + argument1 + ')';
        }
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    }
};

Blockly.Arduino['text_append'] = function (block) {
    var varName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
    var argument0 = Blockly.Arduino.valueToCode(block, 'TEXT', Blockly.Arduino.ORDER_NONE) || '\'\'';
    return varName + ' += ' + argument0 + ';\n';
};

Blockly.Arduino['text_length'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '\'\'';
    return [argument0 + '.length()', Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['text_isEmpty'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '\'\'';
    return [argument0 + '.isEmpty()', Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['text_indexOf'] = function (block) {
    var operator = block.getFieldValue('END') === 'FIRST' ? 'indexOf' : 'lastIndexOf';
    var argument0 = Blockly.Arduino.valueToCode(block, 'FIND', Blockly.Arduino.ORDER_NONE) || '\'\'';
    var argument1 = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '\'\'';
    var code = argument1 + '.' + operator + '(' + argument0 + ')';
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['text_charAt'] = function (block) {
    var where = block.getFieldValue('WHERE') || 'FROM_START';
    var textOrder = (where === 'RANDOM') ? Blockly.Arduino.ORDER_NONE : Blockly.Arduino.ORDER_UNARY_POSTFIX;
    var text = Blockly.Arduino.valueToCode(block, 'VALUE', textOrder) || '\'\'';
    var code;
    if (where === 'FIRST') {
        code = text + '.charAt(0)';
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    } else if (where === 'LAST') {
        code = text + '.charAt(' + text + '.length() - 1)';
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    } else if (where === 'FROM_START') {
        var at = Blockly.Arduino.getAdjusted(block, 'AT');
        code = text + '.charAt(' + at + ')';
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    } else if (where === 'FROM_END') {
        var at = Blockly.Arduino.getAdjusted(block, 'AT', 1, true);
        code = text + '.charAt(' + text + '.length() - ' + at + ')';
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    } else if (where === 'RANDOM') {
        var functionName = Blockly.Arduino.provideFunction_(
            'textRandomLetter',
            ['String ' + Blockly.Arduino.FUNCTION_NAME_PLACEHOLDER_ + '(String text) {',
                '  int x = random(text.length());',
                '  return text.charAt(x);',
                '}']);
        code = functionName + '(' + text + ')';
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    }
    throw Error('Unhandled option (text_charAt).');
};

Blockly.Arduino['text_getSubstring'] = function (block) {
    var text = Blockly.Arduino.valueToCode(block, 'STRING', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '\'\'';
    var where1 = block.getFieldValue('WHERE1');
    var where2 = block.getFieldValue('WHERE2');
    var at1 = Blockly.Arduino.valueToCode(block, 'AT1', Blockly.Arduino.ORDER_NONE) || '1';
    var at2 = Blockly.Arduino.valueToCode(block, 'AT2', Blockly.Arduino.ORDER_NONE) || '1';
    var code;
    if (where1 === 'FROM_END') {
        at1 = text + '.length() - ' + at1;
    } else if (where1 === 'FIRST') {
        at1 = '0';
    }
    if (where2 === 'FROM_END') {
        at2 = text + '.length() - ' + at2 + ' + 1';
    } else if (where2 === 'LAST') {
        at2 = text + '.length()';
    }
    code = text + '.substring(' + at1 + ', ' + at2 + ')';
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['text_changeCase'] = function (block) {
    var operator = block.getFieldValue('CASE');
    var argument0 = Blockly.Arduino.valueToCode(block, 'TEXT', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '\'\'';
    var code;
    if (operator === 'UPPERCASE') {
        code = argument0 + '.toUpperCase()';
    } else if (operator === 'LOWERCASE') {
        code = argument0 + '.toLowerCase()';
    } else if (operator === 'TITLECASE') {
        var functionName = Blockly.Arduino.provideFunction_(
            'textToTitleCase',
            ['String ' + Blockly.Arduino.FUNCTION_NAME_PLACEHOLDER_ + '(String str) {',
                '  return str.toLowerCase().replace(/\\b\\w/g, function (m) {return m.toUpperCase();});',
                '}']);
        code = functionName + '(' + argument0 + ')';
    }
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['text_trim'] = function (block) {
    var OPERATORS = {
        'LEFT': '.trimStart()',
        'RIGHT': '.trimEnd()',
        'BOTH': '.trim()'
    };
    var operator = OPERATORS[block.getFieldValue('MODE')];
    var argument0 = Blockly.Arduino.valueToCode(block, 'TEXT', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '\'\'';
    return [argument0 + operator, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['text_print'] = function(block) {
    var mode = block.getFieldValue('MODE');
    var argument0 = Blockly.Arduino.valueToCode(block, 'TEXT', Blockly.Arduino.ORDER_NONE) || '""';

    // Verificar se o value é um array e pegar o primeiro elemento
    if (Array.isArray(argument0)) {
        argument0 = argument0[0];
    }

    // Remover os parênteses externos e as aspas
    argument0 = cleanAndStoreText(argument0, 1, -1);

    if (mode === 'PRINTLN') {
        return 'Serial.println(' + argument0 + ');\n';
    } else {
        return 'Serial.print(' + argument0 + ');\n';
    }
};

Blockly.Arduino['text_prompt_ext'] = function (block) {
    var msg = Blockly.Arduino.quote_(block.getFieldValue('TEXT'));
    var code = 'Serial.println(' + msg + ');\n';
    return code;
};
//END TEXT

Blockly.Arduino['lists_create_with'] = function (block) {
    var code = new Array(block.itemCount_);
    for (var n = 0; n < block.itemCount_; n++) {
        code[n] = Blockly.Arduino.valueToCode(block, 'ADD' + n, Blockly.Arduino.ORDER_NONE) || 'null';
    }
    code = '[' + code.join(', ') + ']';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['lists_repeat'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'ITEM', Blockly.Arduino.ORDER_NONE) || 'null';
    var argument1 = Blockly.Arduino.valueToCode(block, 'NUM', Blockly.Arduino.ORDER_NONE) || '0';
    var code = 'Array(' + argument1 + ').fill(' + argument0 + ')';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['lists_length'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '[]';
    return [argument0 + '.length', Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['lists_isEmpty'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '[]';
    return ['!' + argument0 + '.length', Blockly.Arduino.ORDER_LOGICAL_NOT];
};

Blockly.Arduino['lists_indexOf'] = function (block) {
    var argument0 = Blockly.Arduino.valueToCode(block, 'FIND', Blockly.Arduino.ORDER_NONE) || '\'\'';
    var argument1 = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '[]';
    var code = argument1 + '.indexOf(' + argument0 + ')';
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['lists_getIndex'] = function (block) {
    var mode = block.getFieldValue('MODE') || 'GET';
    var where = block.getFieldValue('WHERE') || 'FROM_START';
    var listOrder = (where === 'RANDOM') ? Blockly.Arduino.ORDER_NONE : Blockly.Arduino.ORDER_UNARY_POSTFIX;
    var list = Blockly.Arduino.valueToCode(block, 'VALUE', listOrder) || '[]';
    var code;
    if (where === 'FIRST') {
        code = list + '[0]';
    } else if (where === 'LAST') {
        code = list + '[' + list + '.length - 1]';
    } else if (where === 'FROM_START') {
        var at = Blockly.Arduino.getAdjusted(block, 'AT');
        code = list + '[' + at + ']';
    } else if (where === 'FROM_END') {
        var at = Blockly.Arduino.getAdjusted(block, 'AT', 1, true);
        code = list + '[' + list + '.length - ' + at + ']';
    } else if (where === 'RANDOM') {
        var functionName = Blockly.Arduino.provideFunction_(
            'listsGetRandomItem',
            ['function ' + Blockly.Arduino.FUNCTION_NAME_PLACEHOLDER_ + '(list, remove) {',
                '  var x = Math.floor(Math.random() * list.length);',
                '  if (remove) {',
                '    return list.splice(x, 1)[0];',
                '  } else {',
                '    return list[x];',
                '  }',
                '}']);
        code = functionName + '(' + list + ', ' + (mode !== 'GET') + ')';
    }
    if (mode === 'GET') {
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    } else if (mode === 'GET_REMOVE') {
        return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
    } else if (mode === 'REMOVE') {
        return code + ';\n';
    }
    throw Error('Unhandled combination (lists_getIndex).');
};

Blockly.Arduino['lists_setIndex'] = function (block) {
    var list = Blockly.Arduino.valueToCode(block, 'LIST', Blockly.Arduino.ORDER_ASSIGNMENT) || '[]';
    var mode = block.getFieldValue('MODE') || 'SET';
    var where = block.getFieldValue('WHERE') || 'FROM_START';
    var value = Blockly.Arduino.valueToCode(block, 'TO', Blockly.Arduino.ORDER_ASSIGNMENT) || 'null';
    var code;
    if (where === 'FIRST') {
        code = list + '[0]';
    } else if (where === 'LAST') {
        code = list + '[' + list + '.length - 1]';
    } else if (where === 'FROM_START') {
        var at = Blockly.Arduino.getAdjusted(block, 'AT');
        code = list + '[' + at + ']';
    } else if (where === 'FROM_END') {
        var at = Blockly.Arduino.getAdjusted(block, 'AT', 1, true);
        code = list + '[' + list + '.length - ' + at + ']';
    } else if (where === 'RANDOM') {
        var functionName = Blockly.Arduino.provideFunction_(
            'listsGetRandomItem',
            ['function ' + Blockly.Arduino.FUNCTION_NAME_PLACEHOLDER_ + '(list) {',
                '  var x = Math.floor(Math.random() * list.length);',
                '  return x;',
                '}']);
        code = functionName + '(' + list + ')';
    }
    if (mode === 'SET') {
        return list + '[' + code + '] = ' + value + ';\n';
    } else if (mode === 'INSERT') {
        return list + '.splice(' + code + ', 0, ' + value + ');\n';
    }
    throw Error('Unhandled combination (lists_setIndex).');
};

Blockly.Arduino['lists_getSublist'] = function (block) {
    var list = Blockly.Arduino.valueToCode(block, 'LIST', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '[]';
    var where1 = block.getFieldValue('WHERE1');
    var where2 = block.getFieldValue('WHERE2');
    var at1 = Blockly.Arduino.valueToCode(block, 'AT1', Blockly.Arduino.ORDER_NONE) || '1';
    var at2 = Blockly.Arduino.valueToCode(block, 'AT2', Blockly.Arduino.ORDER_NONE) || '1';
    var code;
    if (where1 === 'FROM_END') {
        at1 = list + '.length - ' + at1;
    } else if (where1 === 'FIRST') {
        at1 = '0';
    }
    if (where2 === 'FROM_END') {
        at2 = list + '.length - ' + at2 + ' + 1';
    } else if (where2 === 'LAST') {
        at2 = list + '.length';
    }
    code = list + '.slice(' + at1 + ', ' + at2 + ')';
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['lists_split'] = function (block) {
    var input = Blockly.Arduino.valueToCode(block, 'INPUT', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '\'\'';
    var delimiter = Blockly.Arduino.valueToCode(block, 'DELIM', Blockly.Arduino.ORDER_NONE) || '\'\'';
    var mode = block.getFieldValue('MODE');
    if (mode === 'SPLIT') {
        var code = input + '.split(' + delimiter + ')';
    } else if (mode === 'JOIN') {
        var code = input + '.join(' + delimiter + ')';
    }
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['lists_sort'] = function (block) {
    var list = Blockly.Arduino.valueToCode(block, 'LIST', Blockly.Arduino.ORDER_UNARY_POSTFIX) || '[]';
    var direction = block.getFieldValue('DIRECTION') === '1' ? '1' : '-1';
    var type = block.getFieldValue('TYPE');
    var getCompareFunctionName = Blockly.Arduino.provideFunction_(
        'listsGetSortCompare',
        ['function ' + Blockly.Arduino.FUNCTION_NAME_PLACEHOLDER_ + '(type, direction) {',
            '  var compare = function (a, b) {',
            '    if (a < b) return -1 * direction;',
            '    if (a > b) return 1 * direction;',
            '    return 0;',
            '  };',
            '  return compare;',
            '}']);
    var code = list + '.slice().sort(' + getCompareFunctionName + '("' + type + '", ' + direction + '))';
    return [code, Blockly.Arduino.ORDER_UNARY_POSTFIX];
};

Blockly.Arduino['math_number'] = function(block) {
  const code = String(block.getFieldValue('NUM'));
  return [code, Blockly.Arduino.ORDER_ATOMIC]
};

Blockly.FieldVariable.prototype.getVariableList = function(opt_type) {
    var variableModelList = this.workspace.getVariablesOfType(opt_type || '');
    variableModelList.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
    var variableNames = variableModelList.map(variable => [variable.name, variable.getId()]);
    return variableNames;
};

// Geradores de Variáveis
Blockly.Arduino['variables_declare_number'] = function(block) {
    var varName = block.getFieldValue('VAR_NAME');
    var type = block.getFieldValue('TYPE');
    var value = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_ATOMIC) || '0';

    if (typeof value[0] === 'string') {
        value = value[0].replace(/[()]/g, '');
    }

    var code = type + ' ' + varName + ' = ' + value + ';\n';
    Blockly.Arduino.definitions_['var_' + varName] = code;
    return code;
};

Blockly.Arduino['variables_declare_text'] = function(block) {
    var varName = block.getFieldValue('VAR_NAME');
    var type = block.getFieldValue('TYPE');
    var value = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_ATOMIC) || '""';

    if (Array.isArray(value)) {
      value = value[0]
    }

    // Remover os parênteses externos e as aspas
    value = cleanAndStoreText(value, 1, -1);

    if (type === 'char') {
        var arraySize = 15;
        if (value.includes(',')) {
            value = '{' + value + '}';
        } else if (value.includes('"')) {
            arraySize = Math.max(arraySize, value.length - 2 + 1);
        }
        var code = type + ' ' + varName + '[' + arraySize + '] = ' + value + ';\n';
    } else {
        var code = type + ' ' + varName + ' = ' + value + ';\n';
    }

    Blockly.Arduino.definitions_['var_' + varName] = code;
    return code;
};

Blockly.Arduino['variables_declare_boolean'] = function(block) {
    var varName = block.getFieldValue('VAR_NAME');
    var value = block.getFieldValue('TYPE');
    var code = 'bool ' + varName + ' = ' + value + ';\n';
    Blockly.Arduino.definitions_['var_' + varName] = code;
    return code;
};

//Get
// Gerador de código para obter variáveis do tipo número
Blockly.Arduino['variables_get_number'] = function(block) {
    var varName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('VAR'), Blockly.Names.NameType.VARIABLE);
    return [varName, Blockly.Arduino.ORDER_ATOMIC];
};

// Gerador de código para obter variáveis do tipo texto
Blockly.Arduino['variables_get_text'] = function(block) {
    var varName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('VAR'), Blockly.Names.NameType.VARIABLE);
    return [varName, Blockly.Arduino.ORDER_ATOMIC];
};


// Gerador de código para obter variáveis do tipo booleano
Blockly.Arduino['variables_get_boolean'] = function(block) {
    var varName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('VAR'), Blockly.Names.NameType.VARIABLE);
    return [varName, Blockly.Arduino.ORDER_ATOMIC];
};


// Geradores de Funções
Blockly.Arduino['procedures_defnoreturn'] = function(block) {
  var branch = Blockly.Arduino.statementToCode(block, 'STACK');
  branch = Blockly.Arduino.addLoopTrap(branch, block.id) || '';
  branch = Blockly.Arduino.prefixLines(branch, '  ');  // Add indentation
  
  const funcName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('NAME'), Blockly.Names.NameType.PROCEDURE);
  const code = 'void ' + funcName + '() {\n' + branch + '\n}';

  // Adiciona o código dos blocos conectados
  var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
  if (nextBlock) {
      code += Blockly.Arduino.blockToCode(nextBlock);
  }
  //Blockly.Arduino.definitions_[funcName] = code;
  return code;
};

Blockly.Arduino['procedures_defreturn'] = function(block) {
  var branch = Blockly.Arduino.statementToCode(block, 'STACK');
  branch = Blockly.Arduino.addLoopTrap(branch, block.id) || '';
  branch = Blockly.Arduino.prefixLines(branch, '  ');  // Add indentation
  const returnValue = Blockly.Arduino.valueToCode(block, 'RETURN', Blockly.Arduino.ORDER_NONE) || '';

  const funcName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('NAME'), Blockly.Names.NameType.PROCEDURE);

  const returnType = returnValue ? 'int' : 'void';
  const code = returnType + ' ' + funcName + '() {\n' + branch + (returnValue ? '  return ' + returnValue + ';\n' : '') + '}\n';

  // Adiciona o código dos blocos conectados
  var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
  if (nextBlock) {
      code += Blockly.Arduino.blockToCode(nextBlock);
  }

  return code;
};

Blockly.Arduino['procedures_callreturn'] = function(block) {
  const funcName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('NAME'), Blockly.Names.NameType.PROCEDURE);
  const args = [];
  for (let i = 0; i < block.arguments_.length; i++) {
    args[i] = Blockly.Arduino.valueToCode(block, 'ARG' + i, Blockly.Arduino.ORDER_NONE) || 'null';
  }
  const code = funcName + '(' + args.join(', ') + ')';
  return [code, Blockly.Arduino.ORDER_FUNCTION_CALL];
};

Blockly.Arduino['procedures_callnoreturn'] = function(block) {
  const funcName = Blockly.Arduino.nameDB_.getName(block.getFieldValue('NAME'), Blockly.Names.NameType.PROCEDURE);
  const args = [];
  for (let i = 0; i < block.arguments_.length; i++) {
    args[i] = Blockly.Arduino.valueToCode(block, 'ARG' + i, Blockly.Arduino.ORDER_NONE) || 'null';
  }
  const code = funcName + '(' + args.join(', ') + ');\n';
  return code;
};

Blockly.Arduino['procedures_ifreturn'] = function(block) {
  const condition = Blockly.Arduino.valueToCode(block, 'CONDITION', Blockly.Arduino.ORDER_NONE) || 'false';
  let code = 'if (' + condition + ') {\n';
  if (block.hasReturnValue_) {
    const value = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_NONE) || 'null';
    code += '  return ' + value + ';\n';
  } else {
    code += '  return;\n';
  }
  code += '}\n';
  return code;
};
//End functions

Blockly.Generator.prototype.valueToCode = function(block, name, outerOrder) {
  if (isNaN(outerOrder)) {
    throw Error('Expecting valid order from block: ' + block);
  }
  var targetBlock = block.getInputTargetBlock(name);
  if (!targetBlock) {
    return ['', Blockly.Generator.ORDER_ATOMIC];
  }

  var tuple = this.blockToCode(targetBlock);
  if (!Array.isArray(tuple)) {
    tuple = [tuple, Blockly.Arduino.ORDER_ATOMIC];
  }
  var code = tuple[0];
  var innerOrder = tuple[1];
  if (isNaN(innerOrder)) {
    throw Error('Expecting valid order from value block: ' + targetBlock.type);
  }
  if (code && outerOrder <= innerOrder) {
    code = '(' + code + ')';
  }
  return [code, innerOrder];
};

Blockly.Generator.prototype.statementToCode = function(block, name) {
  var targetBlock = block.getInputTargetBlock(name);
  if (!targetBlock) {
    return ''; // Se não há bloco conectado, retorna string vazia
  }
  var code = this.blockToCode(targetBlock);
  if (Array.isArray(code)) {
    code = code[0]; // Usa o primeiro elemento do array se for um array
  }

  return code;
};

Blockly.Arduino.blockToCode = function(block) {
  if (!block) {
    return '';
  }

  if (block.isEnabled() && !block.hasDisabledReason()) {
    var func = this[block.type];
    if (typeof func !== 'function') {
      throw Error('Language "Arduino" does not know how to generate code for block type "' + block.type + '".');
    }
    var code = func.call(this, block);

    if (Array.isArray(code)) {
      return code[0] + this.scrub_(block, code[1]);
    } else {
      return this.scrub_(block, code);
    }
  } else {
    return this.scrub_(block, '');
  }
};

function cleanAndStoreText(text, startIndex, endIndex) {
    if (text.startsWith('(') && text.endsWith(')')) {
        let cleanedString = text.slice(startIndex, endIndex);
        let resultList = [cleanedString];
        return resultList[0];
    } else {
        return text;
    }
}

//Custom code
Blockly.Arduino['custom_code'] = function(block) {
  var code = block.getFieldValue('CUSTOM_CODE') + ';\n';
  return code;
};




static/custom_generators.js:
// static/custom_generators.js

Blockly.Msg.LOGIC_HUE = '210'; // Ajuste a cor conforme necessário
Blockly.Msg.LOOPS_HUE = '120'; // Ajuste a cor conforme necessário
Blockly.Msg.MATH_HUE = '230'; // Ajuste a cor conforme necessário
Blockly.Msg.TEXTS_HUE = '160'; // Ajuste a cor conforme necessário
Blockly.Msg.LISTS_HUE = '260'; // Ajuste a cor conforme necessário
Blockly.Msg.COLOUR_HUE = '20'; // Ajuste a cor conforme necessário
Blockly.Msg.VARIABLES_HUE = '330'; // Ajuste a cor conforme necessário
Blockly.Msg.PROCEDURES_HUE = '290'; // Ajuste a cor conforme necessário

Blockly.BlockSvg.START_HAT = true;
Blockly.BlockSvg.prototype.updateColour = function() {
  var colourHex = this.getColour();
  this.svgPath_.setAttribute('fill', colourHex);
  this.svgPath_.setAttribute('stroke', Blockly.utils.colour.darken(colourHex, 0.2));
  var inputList = this.inputList;
  for (var i = 0, input; input = inputList[i]; i++) {
    var fieldList = input.fieldRow;
    for (var j = 0, field; field = fieldList[j]; j++) {
      if (field instanceof Blockly.FieldLabel) {
        field.setText(field.getText());
      }
    }
  }
};

Blockly.FieldLabel.prototype.setText = function(text) {
  if (this.textElement_) {
    this.text_ = text;
    this.textElement_.textContent = text;
    this.textElement_.style.fontWeight = 'bold';
    this.textElement_.style.fill = '#FFFFFF';
  }
};


static/script.js:
// static/script.js
// Função melhorada para solicitar acesso à porta serial
async function requestPort() {
    try {
        const port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        console.log('Porta serial aberta com sucesso');
        return port;
    } catch (err) {
        if (err.name === 'SecurityError') {
            console.error('Permissão negada para acessar a porta serial');
            alert('Permissão para acessar a porta serial foi negada. Por favor, conceda permissão quando solicitado.');
        } else if (err.name === 'NotFoundError') {
            console.error('Nenhuma porta serial selecionada');
            alert('Nenhuma porta serial foi selecionada. Por favor, selecione uma porta.');
        } else {
            console.error('Erro ao solicitar porta:', err);
            alert('Ocorreu um erro ao tentar acessar a porta serial. Verifique se o Arduino está conectado corretamente.');
        }
        return null;
    }
}

// Função para obter a lista de portas disponíveis
async function getPorts() {
    try {
        if ('serial' in navigator) {
            const ports = await navigator.serial.getPorts();
            return ports;
        } else {
            throw new Error('Web Serial API não é suportada neste navegador.');
        }
    } catch (err) {
        console.error('Erro ao obter portas:', err);
        return [];
    }
}

// Função para atualizar a lista de portas no dropdown
async function updatePortList() {
    const selectPort = document.getElementById('serial-port');
    const ports = await navigator.serial.getPorts();
    
    selectPort.innerHTML = '<option value="">Selecione uma porta</option>';
    
    for (let port of ports) {
        const option = document.createElement('option');
        option.value = port.getInfo().usbVendorId;
        option.textContent = `Porta (VendorID: ${port.getInfo().usbVendorId})`;
        selectPort.appendChild(option);
    }
}

async function startSerialMonitor(port) {
    const terminal = document.getElementById('serialMonitor');
    terminal.innerHTML = ''; // Clear the terminal

    const reader = port.readable.getReader();
    const textDecoder = new TextDecoderStream();
    const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
    const readerStream = textDecoder.readable.getReader();

    try {
        while (true) {
            const { value, done } = await readerStream.read();
            if (done) break;
            const newLine = document.createElement('div');
            newLine.textContent = value;
            terminal.appendChild(newLine);
            terminal.scrollTop = terminal.scrollHeight; // Auto-scroll
        }
    } catch (err) {
        console.error('Error reading data:', err);
    } finally {
        reader.releaseLock();
    }
}

async function writeSerialData(port, data) {
    const writer = port.writable.getWriter();
    const textEncoder = new TextEncoder();
    const encodedData = textEncoder.encode(data);
    await writer.write(encodedData);
    writer.releaseLock();
}

document.addEventListener('DOMContentLoaded', function () {
    const selectPort = document.getElementById('serial-port');
    const connectButton = document.getElementById('connect-button');
    
    if (connectButton) {
        connectButton.addEventListener('click', connectToArduino);
    }

    selectPort.addEventListener('click', async function() {
        await updatePortList();
        
        if (selectPort.options.length <= 1) {
            alert('Nenhuma porta serial detectada. Verifique se o Arduino está conectado e tente novamente.');
        }
    });

    document.getElementById('upload-button').addEventListener('click', async function () {
        const selectPort = document.getElementById('serial-port');
        const selectBoard = document.getElementById('board');
        if (!selectPort || !selectBoard) {
            console.error('Dropdown element not found');
            return;
        }
        const selectedPort = selectPort.value;
        const selectedBoard = selectBoard.value;
        if (!selectedPort || !selectedBoard) {
            console.error('No port or board selected');
            return;
        }

        const code = Blockly.Arduino.workspaceToCode(Blockly.getMainWorkspace());

        try {
            const port = await requestPort();
            await writeSerialData(port, code);
            alert('Code uploaded successfully!');
            startSerialMonitor(port);
        } catch (error) {
            console.error('Error uploading to Arduino:', error);
            alert('Upload failed');
        }
    });

    if (typeof Blockly === 'undefined') {
        console.error('Blockly is not defined.');
        return;
    }

    // Após carregar todos os blocos
    setTimeout(() => {
        if (Blockly.Blocks['math_change']) {
            delete Blockly.Blocks['math_change'];
        }
    }, 1000); // Ajuste o tempo conforme necessário
    
    Blockly.Themes.blackbg = Blockly.Theme.defineTheme('blackbg', {
        'base': Blockly.Themes.Classic,
        'componentStyles': {
            'workspaceBackgroundColour': '#1e1e1e',
            'toolboxBackgroundColour': 'blackBackground',
            'toolboxForegroundColour': '#fff',
            'flyoutBackgroundColour': '#252526',
            'flyoutForegroundColour': '#ccc',
            'flyoutOpacity': 1,
            'scrollbarColour': '#797979',
            'insertionMarkerColour': '#fff',
            'insertionMarkerOpacity': 0.3,
            'scrollbarOpacity': 0.4,
            'cursorColour': '#d0d0d0',
            'blackBackground': '#333',
        }
    });

    const workspace = Blockly.inject('blocklyDiv', {
        toolbox: document.getElementById('toolbox'),
        theme: Blockly.Themes.blackbg,
        zoom: {
            controls: true,
            wheel: true,
            startScale: 1.0,
            maxScale: 3,
            minScale: 0.3,
            scaleSpeed: 1.2
        },
        grid: {
            spacing: 20,
            length: 3,
            colour: '#ccc',
            snap: true
        },
        trashcan: true,
    });

    // Definindo Blockly.Arduino caso não esteja definido
    if (typeof Blockly.Arduino === 'undefined') {
        Blockly.Arduino = new Blockly.Generator('Arduino');
        Blockly.Arduino.addReservedWords('code');
        Blockly.Arduino.ORDER_ATOMIC = 0;
        Blockly.Arduino.ORDER_NONE = 99;
    }

    Blockly.Variables.createVariableButtonHandler = function(workspace, opt_callback, opt_types) {
        Blockly.prompt('Enter a name for your variable:', '', function(text) {
            if (text) {
                const variableTypes = opt_types || [''];
                Blockly.Variables.getOrCreateVariablePackage(workspace, null, text, variableTypes[0]);
                if (opt_callback) {
                    opt_callback(text);
                }
                workspace.updateToolbox(document.getElementById('toolbox'));
            }
        });
    };

    // Adicionando o callback para o botão de criação de variável
    workspace.registerButtonCallback('createVariable', function(button) {
        Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace())
            .then(() => workspace.updateToolbox(document.getElementById('toolbox')));
    });

    workspace.registerButtonCallback('createTypedVariable', function(button) {
        Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace(), null, ['Number', 'String', 'Boolean']);
        workspace.updateToolbox(document.getElementById('toolbox'));
    });

    let language = 'arduino';

    window.updateLanguage = function () {
        language = 'arduino';
        Blockly.Arduino = new Blockly.Generator('Arduino');
        Blockly.Arduino.addReservedWords('code');
        Blockly.Arduino.nameDB_ = new Blockly.Names(Blockly.Arduino.RESERVED_WORDS_);
        Blockly.Arduino.nameDB_.populateVariables(Blockly.Variables.allUsedVarModels(workspace));
        Blockly.Arduino.nameDB_.populateProcedures(Blockly.Procedures.allProcedures(workspace));
        updateCode();
    };

    //To generators
    Blockly.Arduino.valueToCode = function(block, name, outerOrder) {
        if (isNaN(outerOrder)) {
            throw Error('Expecting valid order from block: ' + block);
        }
        var targetBlock = block.getInputTargetBlock(name);
        if (!targetBlock) {
            return ['', Blockly.Arduino.ORDER_ATOMIC];
        }

        var tuple = Blockly.Arduino.blockToCode(targetBlock);
        if (!Array.isArray(tuple)) {
            tuple = [tuple, Blockly.Arduino.ORDER_ATOMIC];
        }
        var code = tuple[0];
        var innerOrder = tuple[1];
        if (isNaN(innerOrder)) {
            throw Error('Expecting valid order from value block: ' + targetBlock.type);
        }
        if (code && outerOrder <= innerOrder) {
            code = '(' + code + ')';
        }

        return [code, innerOrder];
    };

    Blockly.Arduino.statementToCode = function(block, name) {
      var targetBlock = block.getInputTargetBlock(name);
      if (!targetBlock) {
        return ''; // Se não há bloco conectado, retorna string vazia
      }
      var code = Blockly.Arduino.blockToCode(targetBlock);
      if (Array.isArray(code)) {
        code = code[0]; // Usa o primeiro elemento do array se for um array
      }
      return code;
    };

    Blockly.Arduino.blockToCode = function(block) {
        if (!block) {
            return '';
        }

        if (block.isEnabled() && !block.hasDisabledReason()) {
            var func = this[block.type];
            if (typeof func !== 'function') {
                throw Error('Language "Arduino" does not know how to generate code for block type "' + block.type + '".');
            }
            var code = func.call(this, block);

            // Se code não for um array, transforma em uma tupla
            if (!Array.isArray(code)) {
                code = [code, Blockly.Arduino.ORDER_ATOMIC];
            }

            // Adiciona o código dos blocos conectados abaixo
            var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
            var nextCode = this.blockToCode(nextBlock);

            if (Array.isArray(nextBlock)) {
                nextBlock = nextBlock[0];
            }
            if (Array.isArray(nextCode)) {
                nextCode = nextCode[0];
            }

            return [code[0] + nextCode, code[1]];
        } else {
            return this.scrub_(block, '');
        }
    };

    Blockly.Arduino.scrub_ = function(block, code) {
        const nextBlock = block.nextConnection && block.nextConnection.targetBlock();
        const nextCode = Blockly.Arduino.blockToCode(nextBlock);
        return code + nextCode;
    };

    Blockly.Arduino.workspaceToCode = function(workspace) {
      if (!workspace) {
        console.warn('Blockly.Generator.workspaceToCode was called with an invalid workspace.');
        return '';
      }
      var code = [];
      this.init(workspace);
      var blocks = workspace.getTopBlocks(true);
      for (var i = 0, block; block = blocks[i]; i++) {
        var line = this.blockToCode(block);
        if (line) {
          if (Array.isArray(line)) {
            line = line[0];
          }
          code.push(line);
        }
      }
      code = code.join('\n');
      code = this.finish(code);
      return code;
    };

    function updateCode() {
      Blockly.Arduino.init(Blockly.getMainWorkspace());
      var code;
      let languageClass;
      let generator;
      try {
        switch (language) {
          case 'arduino':
            generator = Blockly.Arduino;
            languageClass = 'language-cpp';
            break;
          default:
            generator = Blockly.Arduino;
            languageClass = 'language-cpp';
            break;
        }

        generator.init(workspace);
        code = generator.workspaceToCode(Blockly.getMainWorkspace());

      } catch (error) {
        code = "// Error generating code: " + error.message;
        languageClass = 'language-cpp';
        console.error('Error generating code:', error);
      }

      const output = document.getElementById('code-output');
      output.textContent = code;
      output.className = 'hljs ' + languageClass;
      hljs.highlightElement(output);
    }

    document.getElementById('executeBtn').addEventListener('click', async () => {
        const code = Blockly.Arduino.workspaceToCode(workspace);
        const selectPort = document.getElementById('serial-port');
        const selectBoard = document.getElementById('board');
        const port = selectPort.value;
        const board = selectBoard.value;

        if (!port) {
            alert('Please select a serial port');
            return;
        }

        try {
            const port = await navigator.serial.requestPort();
            await port.open({ baudRate: 9600 });

            const writer = port.writable.getWriter();
            const encoder = new TextEncoder();
            const encodedCode = encoder.encode(code);
            await writer.write(encodedCode);
            writer.releaseLock();

            startSerialMonitor(port);
        } catch (error) {
            console.error('Error uploading to Arduino:', error);
        }
    });

    document.getElementById('saveBtn').addEventListener('click', function () {
        const xml = Blockly.Xml.workspaceToDom(workspace);
        const xmlText = Blockly.Xml.domToPrettyText(xml);
        const blob = new Blob([xmlText], {type: 'text/xml'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'blockly_blocks.xml';
        a.click();
    });

    document.getElementById('openBtn').addEventListener('click', function () {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.xml';
        input.onchange = function (event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const xmlText = e.target.result;
                    const xml = Blockly.utils.xml.textToDom(xmlText);
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    refreshVariables(workspace);
                };
                reader.readAsText(file);
            }
        };
        input.click();
    });

    const extensionInput = document.getElementById('extensionInput');

    Blockly.getMainWorkspace().registerButtonCallback('sendExtension', function() {
        extensionInput.click();
    });

    function getBlocksFromScript(scriptContent) {
        const blockTypes = [];
        const blockDefRegex = /Blockly\.Blocks\['(.*?)'\]/g;
        let match;
        while ((match = blockDefRegex.exec(scriptContent)) !== null) {
            blockTypes.push(match[1]);
        }
        return blockTypes;
    }

    function registerExtension(scriptContent) {
        const extensionRegex = /Blockly\.Extensions\.register\('(.*?)',\s*function\s*\(\)\s*{([\s\S]*?)}\);/g;
        let match;
        while ((match = extensionRegex.exec(scriptContent)) !== null) {
            const extensionName = match[1];
            const extensionCode = match[2];
            try {
                eval(`Blockly.Extensions.register('${extensionName}', function() {${extensionCode}});`);
            } catch (error) {
                console.error(`Error registering extension ${extensionName}:`, error);
            }
        }
    }

    function registerGenerators(scriptContent) {
        function createAndRegisterGenerator(language, blockType, generatorCode) {
            if (!Blockly[language]) {
                Blockly[language] = {};
            }
            try {
                eval(`Blockly.${language}['${blockType}'] = function(block) {${generatorCode}};`);
            } catch (error) {
                console.error(`Error registering ${language} generator for block: ${blockType}`, error);
            }
        }

        const generatorRegex = /Blockly\.(\w+)\['(.*?)'\]\s*=\*\s*function\s*\(block\)\s*{([\s\S]*?)};/g;
        let match;
        while ((match = generatorRegex.exec(scriptContent)) !== null) {
            const language = match[1];
            createAndRegisterGenerator(language, match[2], match[3]);
        }

        const languages = ['Arduino'];
        languages.forEach(language => {
            const generatorRegex = new RegExp(`Blockly\\.${language}\\['(.*?)'\\]\\s*=\\s*function\\s*\\(block\\)\\s*{([\\s\\S]*?)};`, 'g');
            let match;
            while ((match = generatorRegex.exec(scriptContent)) !== null) {
                createAndRegisterGenerator(language, match[1], match[2]);
            }
        });
    }

    extensionInput.addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const scriptContent = e.target.result;
                
                try {
                    (new Function(scriptContent))();

                    registerExtension(scriptContent);
                    registerGenerators(scriptContent);

                    const scriptName = file.name.split('.')[0];
                    const newCategory = document.createElement('category');
                    newCategory.setAttribute('name', scriptName);
                    newCategory.setAttribute('colour', '160');

                    const blocks = getBlocksFromScript(scriptContent);
                    blocks.forEach(block => {
                        const blockNode = document.createElement('block');
                        blockNode.setAttribute('type', block);
                        newCategory.appendChild(blockNode);
                    });

                    const extensionsCategory = document.getElementById('extensionsCategory');
                    const sendExtensionButton = extensionsCategory.querySelector('button');
                    extensionsCategory.insertBefore(newCategory, sendExtensionButton.nextSibling);

                    workspace.updateToolbox(document.getElementById('toolbox'));

                    alert("Extension loaded and registered successfully!");
                } catch (error) {
                    console.error("Error loading extension:", error);
                    alert("Error loading extension:", error);
                }
            };
            reader.readAsText(file);
        }
    });

        function refreshVariables(workspace) {
        const variables = Blockly.Variables.allUsedVarModels(workspace);
        variables.sort((a, b) => a.name.localeCompare(b.name)); // Ordenar as variáveis alfabeticamente

        workspace.getAllBlocks().forEach(block => {
            if (typeof block.updateVariableFieldDropdown === 'function') {
                block.updateVariableFieldDropdown();
            }
        });

        if (workspace.toolbox_) {
            workspace.toolbox_.refreshSelection();
        }
    }

    workspace.addChangeListener(function(event) {
        if (event.type === Blockly.Events.BLOCK_CREATE || 
            event.type === Blockly.Events.BLOCK_DELETE || 
            event.type === Blockly.Events.BLOCK_CHANGE || 
            event.type === Blockly.Events.VAR_CREATE || 
            event.type === Blockly.Events.VAR_DELETE || 
            event.type === Blockly.Events.VAR_RENAME) {
            refreshVariables(workspace);
        }
        updateCode();
    });

    workspace.addChangeListener(updateCode);
});

// Função melhorada para conectar ao Arduino
async function connectToArduino() {
    const selectPort = document.getElementById('serial-port');
    const selectedPortId = selectPort.value;
    
    if (!selectedPortId) {
        alert('Por favor, selecione uma porta antes de conectar.');
        return;
    }
    
    try {
        const port = await requestPort();
        if (port) {
            console.log('Conectado com sucesso à porta:', port.getInfo());
            alert('Conectado com sucesso ao Arduino!');
            // Aqui você pode adicionar lógica adicional após a conexão bem-sucedida
            // Por exemplo, habilitar botões de upload ou iniciar o monitor serial
        }
    } catch (err) {
        console.error('Erro ao conectar à porta:', err);
        alert('Erro ao conectar à porta selecionada. Verifique a conexão e tente novamente.');
    }
}

static/setup.js:
// static/script.js

let workspace = null;

function resizeBlocklyWorkspace() {
    if (workspace) {
        // Obtenha a largura atual do toolbox
        var toolbox = document.getElementsByClassName('blocklyToolboxDiv')[0];
        var toolboxWidth = toolbox.offsetWidth;

        // Ajuste o tamanho do workspace
        var workspaceDiv = document.getElementById('blocklyDiv');
        var workspaceWidth = workspaceDiv.offsetWidth - toolboxWidth;
        
        workspace.setWidth(workspaceWidth);
        workspace.resize();
    }
}

function initBlockly() {
    workspace = Blockly.inject('blocklyDiv', {
        toolbox: document.getElementById('toolbox'),
        scrollbars: true,
        horizontalLayout: false,
        toolboxPosition: 'start',
    });

    workspace.addChangeListener(updateCode);
    
    // Adicione um pequeno atraso para garantir que o toolbox seja renderizado completamente
    setTimeout(resizeBlocklyWorkspace, 100);
}

function updateCode(event) {
    var code = Blockly.JavaScript.workspaceToCode(workspace);
    document.getElementById('code-output').textContent = code;
    hljs.highlightElement(document.getElementById('code-output'));
}

window.addEventListener('resize', resizeBlocklyWorkspace);

document.addEventListener('DOMContentLoaded', function() {

    // Código para redimensionamento
    const container = document.querySelector('.main-content');
    const outputContainer = document.getElementById('output-container');
    const resizeHandle = document.querySelector('.resize-handle');
    let isResizing = false;

    resizeHandle.addEventListener('mousedown', function(e) {
        isResizing = true;
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', stopResize);
    });

    function handleMouseMove(e) {
        if (!isResizing) return;
        const containerRect = container.getBoundingClientRect();
        const newWidth = containerRect.right - e.clientX;
        outputContainer.style.width = `${newWidth}px`;
    }

    function stopResize() {
        isResizing = false;
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', stopResize);
    }

});

static/style.css:
/* static/style.css */

body {
    font-size: 18px !important; 
    font-family: Arial, sans-serif;
    background-color: #2b2b2b;
    color: #f1f1f1;
    margin: 0;
    padding: 0;
}

header {
    background-color: #1e1e1e;
    padding: 10px 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

nav ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    justify-content: center;
}

nav ul li {
    margin: 0 15px;
    position: relative;
}

nav ul li a {
    color: #f1f1f1;
    text-decoration: none;
    font-weight: bold;
}

nav ul li a:hover {
    color: #ff9800;
}

nav ul li ul {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background-color: #1e1e1e;
    padding: 10px 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    z-index: 1000;
}

nav ul li:hover ul {
    display: block;
}

nav ul li ul li {
    margin: 0;
}

nav ul li ul li a {
    padding: 10px 20px;
    display: block;
}

nav ul li ul li a:hover {
    background-color: #444;
}

.container {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    justify-content: flex-start;
    min-height: 100vh;
    padding: 20px;
    box-sizing: border-box;
}

.main-content {
    display: flex;
    flex-direction: row;
    height: calc(100vh - 200px);
    margin-bottom: 20px;
}

.editor-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    margin-right: 10px;
}

.output-container {
    width: 300px;
    min-width: 200px;
    max-width: 50%;
    position: relative;
    background-color: #1e1e1e;
    border: 2px solid #444;
    border-radius: 8px;
    padding: 20px;
    overflow: hidden;
}

.resize-handle {
    position: absolute;
    left: -5px;
    top: 0;
    bottom: 0;
    width: 10px;
    cursor: ew-resize;
}

.blockly-area {
    flex: 1;
    min-height: 200px;
    border: 2px solid #444;
    border-radius: 8px;
    background-color: #1e1e1e;
}

#code-output {
    width: 100%;
    height: calc(100% - 40px);
    border: none;
    background-color: transparent;
    padding: 10px;
    overflow: auto;
    white-space: pre;
}

.serial-monitor-container {
    height: 200px;
}

.serial-monitor {
    height: calc(100% - 40px);
    width: 100%;
    overflow-y: scroll;
    background: #f1f1f1;
    color: #000;
    padding: 10px;
    border: 2px solid #444;
    border-radius: 8px;
    font-family: 'Courier New', Courier, monospace;
}

h2 {
    color: #ffffff;
}

.blocklyText {
    fill: #000000 !important;
}

select, button {
    width: 100%;
    padding: 10px;
    margin-bottom: 10px;
    background-color: #444;
    color: #f1f1f1;
    border: none;
    border-radius: 4px;
}

.hljs {
    background: #1e1e1e;
    color: #f1f1f1;
}

.blocklyTreeLabel {
    color: #ffffff;
    font-weight: bold;
    font-size: 16px !important; /* Aumenta o tamanho da fonte das categorias */
    line-height: 1.5 !important; /* Ajusta o espaçamento entre linhas */
    white-space: normal !important;
    word-wrap: break-word !important;
}

/* Ajuste o tamanho mínimo dos blocos no flyout para evitar cortes */
.blocklyFlyoutButton {
    min-width: 200px !important;
}

.blocklyTreeRow {
    height: auto !important; /* Permite que a altura da linha se ajuste ao conteúdo */
    min-height: 32px !important; /* Define uma altura mínima para as linhas */
    padding-top: 5px !important;
    padding-bottom: 5px !important;
}

/* Aumenta o tamanho da fonte dos blocos no flyout */
.blocklyFlyoutButton .blocklyText {
    font-size: 14px !important;
}

.blocklyFlyoutLabelText {
    font-size: 14px !important;
}

/* Ajusta o tamanho da fonte dos textos dentro dos blocos */
.blocklyText {
    font-size: 12px !important;
}

/* Ajusta o tamanho dos campos de entrada nos blocos */
.blocklyHtmlInput {
    font-size: 12px !important;
}

/* Aumenta o tamanho do ícone de expansão das categorias */
.blocklyTreeIconOpen,
.blocklyTreeIconClosed {
    width: 20px !important;
    height: 20px !important;
}

/* Ajusta o espaçamento dentro do toolbox */
.blocklyToolboxDiv {
    width: 250px !important; /* Aumente este valor conforme necessário */
    padding: 5px !important;
}

/* Ajuste o layout do workspace para acomodar o toolbox mais largo */
.blocklyWorkspace {
    left: 250px !important; /* Deve ser o mesmo valor da largura do toolbox */
}



/* Ajustes adicionais para melhorar a aparência */
#upload-button {
    background-color: #4CAF50;
    color: white;
    cursor: pointer;
}

#upload-button:hover {
    background-color: #45a049;
}

label {
    display: block;
    margin-bottom: 5px;
    color: #ddd;
}

/* Estilos para tornar a interface mais responsiva */
@media (max-width: 768px) {
    .main-content {
        flex-direction: column;
    }

    .editor-container, .output-container {
        width: 100%;
        max-width: 100%;
        margin-right: 0;
        margin-bottom: 20px;
    }

    .resize-handle {
        display: none;
    }
}

/*Controls*/
.arduino-controls-container {
    font-size: 18px !important; 
    margin-bottom: 20px;
    background-color: #333;
    padding: 15px;
    border-radius: 8px;
}

.control-group {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
}

.control-group:last-child {
    margin-bottom: 0;
}

.control-group label {
    flex: 0 0 150px;
    margin-right: 15px;
    color: #f1f1f1;
}

.input-button-group {
    display: flex;
    flex: 1;
}

.input-button-group select {
    font-weight: bold; !important;
    font-size: 30;
    flex: 1;
    margin-right: 10px;
    padding: 8px;
    background-color: #444;
    color: #f1f1f1;
    border: 1px solid #555;
    border-radius: 4px;
}

.input-button-group button {
    font-weight: bold; !important;
    font-size: 30;
    padding: 8px 15px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.input-button-group button:hover {
    background-color: #45a049;
}

#connect-button {
    background-color: #2196F3;
}

#connect-button:hover {
    background-color: #1976D2;
}

#upload-button {
    background-color: #FF9800;
}

#upload-button:hover {
    background-color: #F57C00;
}


